( Retro ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( Copyright [c] 2008 - 2012, Charles Childers                                 )
( Copyright [c] 2009 - 2010, Luke Parrish                                     )
( Copyright [c] 2010,        Marc Simpson                                     )
( Copyright [c] 2010,        Jay Skeer                                        )
( Copyright [c] 2012,        Michal J Wallace                                 )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )


( Kernel Begins ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
IMAGE-SIZE  constant CORE
CORE 0000 + constant HEAP

( Initial Variables ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
mark variable last    ( Pointer to the most recent dictionary header          )
HEAP variable: heap   ( Starting address of the data/code heap                )
variable compiler     ( Is the compiler on or off?                            )
variable which        ( Pointer to dictionary header of the most recently     )
                      ( looked up word                                        )

6 elements memory fb fw fh cw ch

label: copytag   "Retro" $,
label: version   "11.5" $,
label: build     "2012.12.10" $,
label: okmsg     "ok  " $,

t: ,           ( n-  ) heap # @, dup, 1+, push, !, pop, heap # !, ;
t: withClass   ( ac- ) 1-, push, ;
t: .word       (  a- ) compiler # @, 0 # !if , ; then jump: withClass
t: .macro      (  a- ) jump: withClass
t: .data       (  a- ) compiler # @, 0; drop, 1 # , , ;
t: .primitive  (  a- )
    dup, @, 0 # =if compiler # @, -1 # =if 2 # +, @, then then jump: .word

' .word      'WORD  setClass
' .macro     'MACRO setClass
' .data      'DATA  setClass
' .primitive 'PRIM  setClass

' , word: ,
"( n- ) Place TOS **here** and increment **heap** by 1 " :doc

' withClass    word: withClass
"( ac- ) Execute a function via the specified class handler" :doc

' .word          word: .word
"( a- ) Class for normal functions" :doc

' .macro       word: .macro
"( a- ) Class for immediate functions" :doc

' .data          word: .data
"( a- ) Class for data (variables, literals, etc) " :doc

' .primitive   word: .primitive
"( a- ) Class for functions corresponding to VM opcodes; used for simple optimizations" :doc

( Primitives ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
p: dup dup dup, ;
"( n-nn ) Duplicate TOS" :doc

p: 1+  1+  1+, ;
"( n-n ) Increment TOS by 1 " :doc

p: 1-  1-  1-, ;
"( n-n ) Decrement TOS by 1 " :doc

p: swap swap swap, ;
"( xy-yx ) Exchange positions of TOS and NOS" :doc

p: drop drop drop, ;
"( n- ) Drop TOS from the stack" :doc

p: and and and, ;
"( xy-n ) Bitwise AND" :doc

p: or or or, ;
"( xy-n ) Bitwise OR" :doc

p: xor xor xor, ;
"( xy-n ) Bitwise XOR" :doc

p: @ @ @, ;
"( a-n ) Fetch a value from a memory location" :doc
 
p: ! ! !, ;
"( na- ) Store a value to a memory location" :doc

p: + + +, ;
"( xy-n ) Add two values (x+y)" :doc

p: - - -, ;
"( xy-n ) Subtract two values (x-y)" :doc

p: * * *, ;
"( xy-n ) Multiply two values (x*y)" :doc

p: /mod /mod /mod, ;
"( xy-rq ) Divide and Remainder. This performs symmetric division" :doc

p: << << <<, ;
"( xy-n ) Shift bits left (x<<y)" :doc

p: >> >> >>, ;
"( xy-n ) Shift bits right (x>>y)" :doc

p: out out out, ;
"( np- ) Write a value to an I/O port" :doc

p: in in in, ;
"( p-n ) Read a value from an I/O port" :doc

w: wait wait 0 # 0 # out, wait, ;
"( - ) Wait for an I/O event" :doc

w: over over push, dup, pop, swap, ;
"( xy-xyx ) Place a copy of NOS over TOS" :doc

w: not not -1 # xor, ;
"( x-y ) Same as -1 xor; invert TOS and subtract 1" :doc

w: on on -1 # swap, !, ;
"( a- ) Set a variable to -1 (true)" :doc

w: off off 0 # swap, !, ;
"( a- ) Set a variable to  0 (false)" :doc

w: / / /mod, swap, drop, ;
"( xy-q ) Divide two numbers (x/y)" :doc

w: mod mod /mod, drop, ;
"( xy-r ) Modulus of two numbers (x%y)" :doc

w: negate negate -1 # *, ;
"( x-y ) Invert sign of TOS" :doc

w: do do 1-, push, ;
"( a- ) Call a function by address" :doc

w: @+ @+ dup, 1+, swap, @, ;
"( a-ac ) Fetch a value from an address, return the next address and the value" :doc

w: !+ !+ dup, 1+, push, !, pop, ;
"( ca-a ) Store a value to an address, return next address" :doc

( Core Compiler ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
w: here here heap # @, ;
"( -a ) Next free address in **heap**" :doc

m: ;; ;; 9 # , ;
"( - ) Compile an exit into a function, but do not stop compilation" :doc

m: ; t-;  ;; ;; compiler # off ;
"( - ) Compile an exit into a function and stop the compiler" :doc

i: ($,) repeat @+ 0; , again ;
( [ a-a ] internal helper function for inlining strings )

i: $ ($,) drop, 0 # , ;
( [ a- ] internal helper function for inlining strings )

m: push push 5 # , ;
"( n- ) Push a value to the address stack" :doc

m: pop  pop  6 # , ;
"( -n ) Pop a value off the address stack" :doc

( Conditionals and Flow Control ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
m: 0; t-0; 25 # , ;
"( n-n || n- ) If TOS is not zero, do nothing. If TOS is zero, drop TOS and exit the function" :doc

m: repeat t-repeat here ;
"( R: - C: -a ) Start an unconditional loop" :doc

m: again t-again  8 # , , ;
"( R: -  C: a- ) Jump to the code following the most recent **repeat**" :doc

( Console Output ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
-1 variable: update

w: redraw redraw update # @, 0; drop, 0 # 3 # out, ;
"( - ) Update the display. Can be disabled temporarily by **update**" :doc

w: putc putc 0; 1 # 2 # out, wait redraw ;
"( c- ) Display a character" :doc

w: cr cr 10 # putc ;
"( - ) Display a newline character" :doc

i: (puts) repeat @+ 0; putc again ;
( [ a-a ] helper for **puts** )

w: <puts> <puts> (puts) drop, ;
"( $- ) Helper; default way to display strings" :doc

w: puts puts <puts> ;
"( $- ) Display a string" :doc

( Console Input ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
variable  break                       ( Holds the delimiter for 'accept'   )

-1 variable: remapping                   ( Allow extended whitespace?         )

-1 variable: eatLeading?                 ( Eat leading delimiters?            )

-1 variable: tabAsWhitespace

 0 variable: keymap
keymap data: keymap
"( -a ) Variable, determines whether or not to use the keymap" :doc

 9 variable: keymap:PREFIX
keymap:PREFIX data: keymap:PREFIX
"( -a ) Variable, holds prefix for triggering keymap lookups. Default is #9 (tab)" :doc

 0 variable: keymap:TABLE
256 tallot
keymap:TABLE data: keymap:TABLE
"( -a ) Variable, jump table for keymap handlers" :doc


w: STRING-LENGTH STRING-LENGTH  256 # ;
"( -n ) Return the max length for a string" :doc

w: STRING-BUFFERS STRING-BUFFERS 12 # ;
"( -n ) Return number of temporary string buffers" :doc

w: tib tib memory # @, STRING-LENGTH - ;
"(  -a ) Returns address of text input buffer" :doc

w: remapKeys remapKeys ;
"( c-c ) Remap one ASCII value to another" :doc

w: remap:whitespace remap:whitespace
   dup,  127 # =if drop,  8 # then
   dup,   13 # =if drop, 10 # then
   remapping # @, 0; drop,
   dup,   10 # =if drop, 32 # then
   tabAsWhitespace # @, 0; drop, dup, 9 # =if drop, 32 # then ;
"( c-c ) helper for remapping whitespace" :doc

w: getc:unfiltered getc:unfiltered 1 # 1 # out, wait 1 # in, ;
"( -c ) Read a keypress and return the ASCII value on the stack" :doc

w: getc:with/remap getc:with/remap
  repeat getc:unfiltered remapKeys dup, 0 # !if remap:whitespace ; then drop, again ;
"( -c ) Read a keypress and return the ASCII value on the stack.\nThis differs from **getc:unfiltered** in that the key value is processed\nby **remapKeys** before being returned.\nUnlike **getc** it does not attempt to support the keymaps." :doc

w: keymap:handler keymap:handler
  ;
"( c-c ) handle keymaps" :doc

w: getc getc
  repeat getc:unfiltered keymap:handler remapKeys dup, 0 # !if remap:whitespace ; then drop, again ;
"( -c ) Read a keypress and return the ASCII value on the stack.\nBoth remapping and keymaps are handled by this." :doc

i: putc? dup, 8 # =if drop, break # @, ; then dup, putc ;
( [ c-c ] helper to display characters and backspaces properly )

i: eat    ( a-a )
   eatLeading? # @, 0; drop,
   repeat getc putc? dup, break # @, !if swap, !+ ; then drop, again ;
( [ a-a ] helper function to eat leading delimiters )

i: guard? dup, 1+, tib <if drop, tib ; then 8 # putc ;
( [ n-n ] helper to prevent backspacing to before start of buffer )

i: (accept)
   repeat
     getc
     dup, 8 # =if drop, 1-, guard? jump: (accept) then
     dup, putc
     dup, break # @, =if drop, ; then
     swap, !+
   again ;
( [ a-a ] internal implementation of **accept** )

w: accept accept break # !, tib eat (accept) 0 # swap, !+ drop, ;
"( c- ) Read a string, ending with the specified character. The string is returned in **tib**" :doc

( Colon Compiler ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
-1 variable: vector

w: d->class d->class  1+, ;
"( a-a ) Given a dictionary header, return the address of the class handler. Use **@** to get the actual pointer." :doc

w: d->xt d->xt 1+, 1+, ;
"( a-a ) Given a dictionary header, return the address of the function start (*xt*). Use **@** to get the actual pointer." :doc

w: d->doc d->doc 3 # +, ;
"( a-a ) Given a dictionary header, return the address of a documentation string. Use **@** to get the actual pointer." :doc

w: d->name d->name  4 # +, ;
"( a-a ) Given a dictionary header, return the address of the name. This is the actual start of the  name." :doc

w: header header  push, here        ( Entry Start      )
                     last # @, ,       ( Link to previous )
                     last # !,         ( Set as newest    )
                     ' .data # ,       ( Class = .data    )
                     here 0 # ,        ( XT               )
                     0 # ,             ( Pointer to docstr)
                     pop, $            ( Name             )
                     here swap, !, ;   ( Patch XT to HERE )
"( $- ) Given a name, create a new header with a class of **.data**" :doc

w: create create 32 # accept tib header ;
"( ``- ) Parse for a name and call **header**" :doc

m: [[ [[ compiler # off ;
"( - ) Turn compiler off" :doc

w: ]] ]] compiler # on ;
"( - ) Turn compiler on" :doc

i: vector?  vector # @, 0; drop, 0 # , 0 # , ;

w: : :   create ' .word # last # @, d->class !, ]] vector? ;
"( ``- ) Calls **create**, changes class to **.word**, and turns **compiler** on." :doc

m: ( t-(  ') # accept ;
"( ``- ) Parse for ) and ignore everything it reads" :doc

( Quotes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )

( reference diagram:                                           )
(                                                              )
(  step       generated code.                                  )
(  -------    ----------------                                 )
(  [          <quote> 0000                                     )
(  [ 5        <quote> 0000 <lit> 0005                          )
(  [ 5 ]      <quote> ADDR <lit> 0005 <ret>                    )
(                                                              )
( ADDR will be same as "here" immediately after compilation    )
(                                                              )
( <quote> is the xt for "quote" - 711 as of retro 11.5 . This  )
( changes with kernel/meta.rx but the number should always be  )
( the same as both:  ' quote     and:  d' quote @d->xt         )

w: quote quote ( -a  ) ( -- runtime -------------------------------- )
  pop, 1+        (   -a  | grab the return address, add 1, and )
  dup,           (  a-aa | dup, giving two pointers to ADDR    )
  @,             ( aa-aA | dereference one for actual target   )
  1-,            ( aa-aA | subtract 1 because ip++ in ngaro vm )
  push,          ( aA-a  | push result to do a calculated jump )
  1+, ;          (  a-a  | point to start of code, jump to end )
"( -a ) Helper function for quotations" :doc

m: [ [ ( -a )      ( -- compile-time---------------------------- )
  ' quote # ,    (   -   | compile a call to quote             )
  here           (   -a  | remember where to put ADDR          )
  0 # ,          (  a-a  | leave a cell to hold it later       )
  compiler # @,  (  a-af | store current compiler state        )
  compiler # on  ( af-af | turn the compiler on                )
  ;
"( - ) Start a quote (code block)" :doc

m: ] ] ( af- ) ( a = placeholder for quote jump, f = old compile state  )
   ;;            ( af-af | compile a return from quoted code   )
   compiler # !, ( af-a  | restore compiler state              )
   here          (  a-aA | now we know what ADDR should be     )
   over !,       ( aA-a  | so go replace the 00                )
   compiler # @, (  a-af | recall current compile state        )
   0 # =if       ( af-a  | are we outside of the compiler?     )
                 ( -- runtime -------------------------------- )
     1+, ;       (  a-a  | for interactive, keep ptr to start  )
                 ( -- compile-time---------------------------- )
   then drop, ;  (  a-   | inside compile mode, just discard.  )
                 (       | the call to 'quote will restore it  )
                 (       | when the containing function runs   )
"( -a ) End a quote (code block)" :doc

( Combinators ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
i: empty ;
( [ - ] internal helper corresponding to an empty quote )

w: if if push, swap, pop, swap, 0 # !if drop, do ; then swap, drop, do ;
"( fqq- ) Execute first quote if flag is true, second  if false" :doc

w: ifTrue ifTrue   ' empty # if ;
"( fq- ) Execute quote if flag is true" :doc

w: ifFalse ifFalse ' empty # swap, if ;
"( fq- ) Execute quote if flag is false" :doc

w: dip dip swap, push, do pop, ;
"( nq-n ) Call a quote while temporarily hiding the top item on the stack" :doc

w: sip sip over ' do # dip ;
"( nq-n ) Call a quote with an item on the stack, restoring that item after the quote returns" :doc

( Conditionals ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
i: false (  -n  )  0 # ;
( [ -f ] helper, returns 0 for false )

i: true  (  -n  ) -1 # ;
( [ -f ] helper, returns -1 for true )

w: =  =  ( xy-f  ) =if jump: true  then jump: false
"( xy-f ) Compare two values for equality. Use **==** instead" :doc

w: == == = ;
"( xy-f ) Compare two values for equality." :doc

w: <> <>  ( xy-f  ) !if jump: true  then jump: false
"( xy-f ) Compare two values for inequality. Use **!=** instead." :doc

w: != != <> ;
"( xy-f ) Compare two values for inequality." :doc

w: >= >=  ( xy-f  ) >if jump: true  then jump: false
"( xy-f ) Compare for greater than or equal to" :doc

w: <= <=  ( xy-f  ) <if jump: true  then jump: false
"( xy-f ) Compare for less than or equal to" :doc

w: < <    ( xy-f  ) >if jump: false then jump: true
"( xy-f ) Compare two values for less than" :doc

w: > >    ( xy-f  ) <if jump: false then jump: true
"( xy-f ) Compare two values for greater than" :doc

( Strings ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
w: compare compare
   repeat
     dup, @, push, 1+, swap,
     dup, @, push, 1+, pop, dup, pop,
     !if drop, drop, dup, xor, ; then
   0 # 12 m, m,
   drop, drop, -1 # ;
"( $$-f ) Compare two strings for equality" :doc

i: count repeat @+ 0; drop, again ;
( [ a-a ] internal helper for getting string length )

w: getLength getLength   ( a-n ) dup, count 1-, swap, -, ;
"( a-n ) Return the length of a string" :doc

w: withLength withLength  ( a-an ) dup, getLength ;
"( a-an ) Same as **dup getLength**" :doc

w: string string      ( -   ) pop, count 1-, push, ;
"( - ) helper for strings" :doc

w: keepString keepString  ( a-a ) ' string # , here swap, $ ;
"( a-a ) Move the string to a permanent location" :doc

w: :devector :devector ( a-  ) 0 # swap, !+ 0 # swap !, ;
"( a- ) Restore a function to its original state" :doc

w: :is :is      ( aa- ) 8 # swap, !+ !, ;
"( aa- ) Alter a function to point to a new function" :doc

w: atib atib memory # @, STRING-LENGTH 2 # * - ;
"(  -a ) Returns address of alternate text input buffer" :doc

w: " t-" ' atib # ' tib # :is '" # accept ' tib # :devector atib ;
"( ``-$ ) temporary function to create strings until __`` is defined" :doc

( Numbers [Parsing & Display] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
4 elements #value num negate? flag

10 variable: base

label: numbers "0123456789ABCDEF" $,

w: numbers nums     ( -a ) numbers # ;
"(  -a ) Function returning address of string containing all valid numeric characters" :doc

i: @base    ( -n ) base # @, ;
( [ -n ] helper function, returns value stored in **base** )

i: (digits) nums +, @, over =if num # on then ;
( NEEDS-DESCRIPTION )

i: digits   1-, repeat dup, push, (digits) pop, 0; 1-, again ;
( NEEDS-DESCRIPTION )

i: valid?   @base dup, 16 # <if digits ; then drop, ;
( NEEDS-DESCRIPTION )

i: digit?   num # off valid? drop, num # @, ;
( NEEDS-DESCRIPTION )

i: toDigit  ( c-n ) '0 # -, @base 16 # =if dup, 16 # >if 7 # -, then then ;
( NEEDS-DESCRIPTION )

i: isNegative? ( a-a )
   dup, @, '- # =if negate? # on 1+, ; then 1 # negate? # !, ;
( NEEDS-DESCRIPTION )

i: (convert)
   repeat
     dup, @, 0; toDigit #value # @, @base *, +, #value # !, 1+,
   again ;
( NEEDS-DESCRIPTION )

w: toNumber toNumber ( $-n )
   isNegative? 0 # #value # !, (convert) drop, #value # @, negate? # @, *, ;
"( $-n ) Convert a string to a number" :doc

i: (isnumber)
   repeat dup, @, 0; digit? flag # @, and, flag # !, 1+, again ;
( NEEDS-DESCRIPTION )

w: isNumber? isNumber? ( $-f ) isNegative? flag # on (isnumber) drop, flag # @, ;
"( $-f ) See if a string is a valid number in the current **base**" :doc

( Startup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
w: boot boot         (  -  )
   copytag # puts 32 # putc version # puts cr ;
"( - ) Called when the image first loads; use for custom startup routines" :doc

i: query        ( n-n ) 5 # out, wait 5 # in, ;
( NEEDS-DESCRIPTION )

i: run-on-boot  (  -  )
   -1  # query memory # !,  ( Memory Size     )
   -2  # query fb #     !,  ( Canvas Present? )
   -3  # query fw #     !,  ( Canvas Width    )
   -4  # query fh #     !,  ( Canvas Height   )
   -11 # query cw #     !,  ( Console Width   )
   -12 # query ch #     !,  ( Console Height  )
   boot ;
( NEEDS-DESCRIPTION )

( Dictionary Search ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
2 elements name found

i: prepare  ( a-a  ) found # off name # !, last # @, ;
( NEEDS-DESCRIPTION )

i: done     (  -af ) which # @, found # @, ;
( NEEDS-DESCRIPTION )

i: match?   ( $-$f ) dup, d->name name # @, compare ;
( NEEDS-DESCRIPTION )

i: <search> ( $-   )
   repeat match? 0 # !if which # !, found # on ; then @ 0; again ;
( NEEDS-DESCRIPTION )

w: find find     ( $-af ) prepare <search> done ;
"( $-af ) Search for a name in the dictionary. Returns  a dictionary header and a flag" :doc

w: ' t-'      ( "-a  ) 32 # accept tib find 0 # !if d->xt @, ; then drop, 0 # ;
"( ``-a ) Interpret time: return the address ('xt') of a name" :doc

( Word Prefixes and "Not Found" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
label: ___   "___" $,

i: get      ( $-$  ) dup, @, ___ # 2 # +, !, 1+, ;
( NEEDS-DESCRIPTION )

i: xt:class ( d-aa ) dup, d->xt @, swap, d->class @, ;
( NEEDS-DESCRIPTION )

i: try      (  -   )
   tib get find 0 #
   !if d->xt @, ___ # find
      0 # !if xt:class withClass 0 # ; then drop,
   then drop, -1 # ;
( NEEDS-DESCRIPTION )

w: <notFound> <notFound> ( -f ) tib getLength 2 # >if try then ;
"( -f ) Called by **notFound**; hook for custom error handling. Used by the prefix system. Returns  a flag of 0 if the error is cleared, or -1 if not " :doc

w: notFound notFound   ( -  ) <notFound> 0; drop, cr tib puts 32 # putc '? # putc cr ;
"( - ) Called when a name is not found. Calls **<notFound>** and displays an error message  if necessary" :doc

( Listener ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
w: ok ok      (   - ) compiler # @, not 0; drop, cr okmsg # puts ;
"( - ) Displays the ``ok`` prompt" :doc

i: build#  (   - ) tib toNumber ' .data # jump: withClass
( NEEDS-DESCRIPTION )

i: number  (   - ) tib isNumber? 0 # !if jump: build# then jump: notFound
( NEEDS-DESCRIPTION )

i: process ( af- ) 0 # !if xt:class jump: withClass then drop jump: number
( NEEDS-DESCRIPTION )

w: listen listen  (   - ) repeat ok 32 # accept tib find process again ;
"( - ) Top level interpreter. Reads and process input." :doc

( Initial Dictionary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
last         data: last
"( -a ) Variable; pointer to most recent dictionary  header" :doc

compiler     data: compiler
"( -a ) Variable; holds compiler state" :doc

fb           data: fb
"( -a ) Variable; Is canvas present?" :doc

fw           data: fw
"( -a ) Variable; Framebuffer width" :doc

fh           data: fh
"( -a ) Variable; Framebuffer height" :doc

memory       data: memory
"( -a ) Variable; Holds amount of memory provided by the VM" :doc

cw           data: cw
"( -a ) Variable; Console width" :doc

ch           data: ch
"( -a ) Variable; Console height" :doc

heap         data: heap
"( -a ) Variable; Pointer to current free location in heap" :doc

which        data: which
"( -a ) Variable; Holds pointer to most recently looked up header" :doc

remapping    data: remapping
"( -a ) Variable; indicates whether CR, LF, and TAB should be treated as whitespace" :doc

eatLeading?  data: eatLeading?
"( -a ) Variable; indicates whether **accept** should ignore leading delimiters" :doc

base         data: base
"( -a ) Variable; holds current base for numeric conversion and display" :doc

update       data: update
"( -a ) Variable; flag indicating whether or not **redraw** should update the display" :doc

version      data: version
"( -$ ) String holding version information" :doc

build        data: build
"( -$ ) String holding a build identifier" :doc

vector       data: vector
"( -a ) Variable; compile function as a vector" :doc

tabAsWhitespace data: tabAsWhitespace
"( -a ) Variable; treat tab as whitespace?" :doc

patch

( Finish Metacompiled Part ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
main: run-on-boot jump: listen
endKernel shrink bootNew


( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( Ok, at this point the new image should be in control so we have a normal,   )
( though brutally minimal Retro system from here on.                          )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )

: :doc keepString last @ d->doc ! ;
" ( $- ) attach documentation string to latest defined function" :doc


( Stack Words ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
: nip   (  xy-y    ) swap drop ;
" ( xy-y ) Drop the NOS from the stack" :doc

: rot   ( xyz-yzx  ) push swap pop swap ;
" ( xyz-yzx ) Rotate the top three values on the stack" :doc

: tuck  (  xy-yxy  ) swap over ;
" ( xy-yxy ) Put a copy of TOS under NOS" :doc

: +!    (  na-     ) dup push @ + pop ! ;
" ( na- ) Add value to value at address" :doc

: -!    (  na-     ) dup push @ swap - pop ! ;
" ( na- ) Subtract value from value at address" :doc

: ++    (   a-     ) 1 swap +! ;
" ( a- ) Increment variable by 1" :doc

: --    (   a-     ) 1 swap -! ;
" ( a- ) Decrement variable by 1" :doc

: ?dup  (   n-n || n-nn )  dup 0; ;
" ( -n ) Duplicate TOS if non-zero. If zero, leave value alone" :doc

( Scope ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
create list  ( -a )  0 , 0 ,

: {{ ( - )  vector off last @ dup list !+ ! ;
" ( - ) Start a namespace (private portion)" :doc

: ---reveal--- ( - ) vector on last @ list 1+ ! ;
" ( - ) Switch to public portion of a namespace" :doc

: }} ( - )
  vector on list @+ swap @ ==
  [ list @ last ! ]
  [ list @ [ last repeat @ dup @ list 1+ @ != 0; drop again ] do ! ] if ;
" ( - ) Close a namespace, sealing off private symbols" :doc

( Vectored Execution ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
: devector  ( "-  ) ' 0; :devector ;
" ( ``- ) Same as **:devector**, but parses for name of function" :doc

: is        ( a"- ) ' 0; :is ;
" ( a``- ) Same as **:is**, but parses for name of function" :doc

: default:  ( "-  ) ' 2 + , ; ' .macro last @ d->class !
" ( ``- ) Compile call to default definition of a function, ignoring any revectoring" :doc

: HEADERS   (  -n ) 32 ;
" ( -n ) Returns number of private headers permitted" :doc

{{
  : scratch  ( -a )
    memory @       STRING-LENGTH   -  ( tib     )
                   STRING-LENGTH   -  ( scratch )
    STRING-BUFFERS STRING-LENGTH * -  ( buffers )
    HEADERS dup STRING-LENGTH * swap 3 * + -  ( headers ) ;

  create next  0 ,
  create split 0 ,

  [ split @
    [ heap @ [ next @ heap ! default: header heap @ next ! ] dip heap ! here last @ d->xt ! ]
    [ default: header ] if ] is header

  create z
     999 , 999 , 0 ,

  [ split  on scratch next ! default: {{           z header ] is {{
  [ split off                default: ---reveal---          ] is ---reveal---
  [ split off                default: }}                    ] is }}
}}

( Dictionary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
{{
  create a 0 , create b 0 , create c 0 , create xt 0 ,
  : skim       ( a-a )
    last repeat @ over over d->xt @ == [ nip 0 ] ifTrue 0; again ;
  : getHeaders ( $-  )
    xt ! 0 a ! 0 b ! 0 c !
    last repeat @ 0; dup d->xt @ xt @ == [ dup b ! @ a ! 0 ] [ -1 ] if 0; drop dup c ! again ;
  : <hide>     ( a-  ) getHeaders b @ 0; drop a @ c @ ! ;
---reveal---
  : d'         ( "-a ) ' drop which @ ;
  " ( ``-a ) Parse for a name and return the dictionary header corresponding to it" :doc

  : xt->d      ( a-d || a-0 ) dup skim over over == [ - ] [ nip ] if ;
  " ( a-d ) Given an address, return the corresponding dictionary header or 0 if not found" :doc

  : :hide      ( a-  )
    dup xt->d last @ == [ drop last @ @ last ! ] [ <hide> ] if ;
  " ( a- ) Remove a name from a dictionary. Specify the address of a function. Used by **hide**" :doc
  
  : hide       ( "-  ) ' 0; :hide ;
  " ( ``- ) Remove a name from the dictionary" :doc
}}
hide list
hide vector

: reclass      (  a- ) last @ d->class ! ;
" ( a- ) Change class of most recent function to specified class" :doc

: reclass:     ( a"- ) d' d->class ! ;
" ( a``- ) Same as **reclass**, but parse for function to change class of" :doc

( Initial Prefixes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
{{
  : xt:class ( a-aa ) dup xt->d 0; d->class @ withClass ;
---reveal---
  : __&  ( a-a ) .data                  ; &.macro reclass
  " ( a-a ) Prefix; returns address of a variable or function" :doc

  : __@  ( a-n ) xt:class &@  xt:class  ; &.macro reclass
  " ( a-n ) Prefix; execute function or data element and fetch from addres returned" :doc

  : __!  ( na- ) xt:class &!  xt:class  ; &.macro reclass
  " ( na- ) Prefix; execute function or data element and store value to address returned" :doc

  : __+  ( na- ) xt:class &+! .word     ; &.macro reclass
  " ( na- ) Prefix; execute function or data element and add value to value at address returned" :doc

  : __-  ( na- ) xt:class &-! .word     ; &.macro reclass
  " ( na- ) Prefix; execute function or data element and subtract value from value at address returned" :doc

  : __2  ( a-  ) &xt:class sip xt:class ; &.macro reclass
  " ( a- ) Prefix; execute function twice" :doc
}}

( Classes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
: .compiler    (  a- ) @compiler &do &drop if ;
" ( a- ) Class for functions that can only be used inside a definition" :doc

: immediate    (   - ) &.macro reclass ;
" ( - ) Set the most recent function to **.macro** class" :doc

: compile-only (  "- ) &.compiler reclass ;
" ( ``- ) Set the most recent function to **.compiler** class" :doc

( Remap some classes for efficiency and safety ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
here
{{
  : c: ( "- ) &.compiler reclass: ;
  c: pop    c: push   c: 0;     c: ;;    c: ;      c: repeat c: again
}}
!heap

( Compiler Macros ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
: `     ( "-  )
  ' ?dup 0 != -1 ==
  [ .data @which @d->class , ]
  [  tib isNumber? -1 ==
    [ tib toNumber .data &.data , ] &notFound if ] if ; compile-only
" ( ``- ) Either execute a function, or compile the xt  and a call to the corresponding class         handler. This will also work with numbers" :doc

: jump: ( "- ) ' 0; 8 , , ; compile-only
" ( ``- ) Compile a jump to another function" :doc

( Additional Combinators ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
: []      (    -    ) ` [ ` ] ; immediate
" ( - ) Empty quote" :doc

: while   (   q-    ) [ repeat dup dip swap 0; drop again ] do drop ;
" ( q- ) Execute quote until quote returns a flag of" :doc

: until   (   q-    ) [ repeat dup dip swap not 0; drop again ] do drop ;
" ( q- ) Execute quote until quote returns a flag of -1" :doc

: curry   (  nq-q   ) [ [ ` [ ] dip .data ] dip , ` ] ;
" ( nq-q ) 5 [ . ]   =  [ 5 [ . ] do ]" :doc

: take    (  qq-q   ) swap [ [ ` [ ] dip , ] dip .data ` ] ;
" ( qq-q ) 5 [ . ]   =  [ [ . ] do 5 ]" :doc

: bi      (  xqq-   ) &sip dip do ;
" (  xqq- ) Apply each quote to a copy of x" :doc

: bi*     ( xyqq-   ) &dip dip do ;
" ( xyqq- ) Apply q1 to x and q2 to y" :doc

: bi@     (  xyq-   ) dup bi* ;
" (  xyq- ) Apply q to x and y" :doc

: tri     ( xqqq-   ) [ &sip dip sip ] dip do ;
" ( xqqq- ) Apply each quote to a copy of x" :doc

: tri*    ( xyzqqq- ) [ [ swap &dip dip ] 2dip ] dip do ;
" ( xyzqqq- ) Apply q1 to x, q2 to y, and q3 to z" :doc

: tri@    ( xyzq-   ) 2dup tri* ;
" ( xyzq- ) Apply q to x, y, and z" :doc

: cons    (  ab-q   ) 2push ` [ 2pop &.data bi@ ` ] ;
" ( ab-q ) Create a quote returning two data elements" :doc

: preserve ( aq-    ) swap &@ sip [ &do dip ] dip ! ;
" ( aq- ) Given a variable (a) and a quote (q), preserve the contents of (a) while executing  the quote, and restore the original contents  of (a) after execution completes. (a) is removed from the stack before (q) is executed." :doc

: when    (  nqq-n  )
  [ over swap do ] dip swap
  [ do -1 ] [ drop 0 ] if 0; pop 2drop ;
" ( nqq-n ) Execute q1, with a copy of n on the stack.\n\nIf q1 returns a true flag, run q2 and exit the caller.\n\nIf not, discard q2 and return to the  caller.\n\nq2 is permitted to discard n, which will alter the stack effect." :doc

: whend   ( nqq-? )
  [ over swap do ] dip swap
  [ nip do -1 ] [ drop 0 ] if 0; pop 2drop ;
" ( nqq-? ) Execute q1, with a copy of n on the stack.\n\nIf q1 returns a true flag, drop n, run q2 and exit the caller.\n\nIf not, discard q2 and return to the caller. " :doc

{{
  : for   ( R: n-  C: -a ) here ` push ; compile-only
  : next  ( R: -   C: a- ) ` pop 7 , , ; compile-only
  : i 2pop pop 2over 2push swap - swap push ;
  : tors  (    -n ) ` pop ` dup ` push ; compile-only
---reveal---
  : times (  nq-  )
    over 1 >= [ swap for dup dip next drop ] [ 2drop ] if ;
  " ( nq- ) Run quote (n) times" :doc

  : iterd (  nq-  )
    over 1 >= [ swap for tors swap dup dip next drop ] [ 2drop ] if ;
  " ( nq- ) Run quote (n) times and push counter to stack each time. Counts down." :doc

  : iter  (  nq-  )
    over 1 >= [ swap dup push for i swap dup dip next pop 2drop ] [ 2drop ] if ;
  " ( nq- ) Run quote (n) times and push counter to stack each time. Counts up." :doc
}}

{{
  : each   (  qa- ) [ [ swap dup &do dip ] sip 1+ ] times 2drop ;
  : array  (  aq- ) swap @+ dup 1 > [ each ] [ 2drop ] if ;
  : buffer ( anq- ) 2rot each ;
  : list   (  lq- ) [ &@ dip 2over [ &do dip ] dip over @ ] while 2drop ;
---reveal---
  : <each@> ( ...t- ) drop ;
  " ( ...t- ) Hook into **each@** for adding additional types" :doc

  : each@   ( ...t- )
    [ 0  ( ARRAY  ) == ] &array                     whend
    [ 1  ( BUFFER ) == ] &buffer                    whend
    [ 2  ( STRING ) == ] [ &withLength dip buffer ] whend
    [ 3  ( LIST   ) == ] &list                      whend
    <each@> ;
  " ( ...t- ) Supercombinator for applying a quote to each item in various data structures.\nProvide one of the following stack forms:\n\n    ARRAY:  aq-\n    BUFFER: anq-\n    STRING: $q-\n    LIST: lq-\n\nFor LIST, *l* should be a variable pointing to the list.\n\nThe quote will be given the address of the current element with each time it is invoked by each@." :doc
}}

( Memory Blocks ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
: copy   ( aan-  ) [ &@+ dip !+ ] times 2drop ;
" ( aan- ) Copy n values from source (a1) to dest (a2)" :doc

: fill   ( ann-  ) swap !here [ @here swap !+ ] times drop ;
" ( ann- ) Fill (n2) memory locations starting at (a) with value (n1)" :doc

( Conditionals ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
: ahead  (   -a  ) 8 , here 0 , ;
" ( -a ) Used in conditionals; compiles a branch to be patched in later" :doc

: if;    (  f-   ) ` not ` 0; ` drop ; compile-only
" ( f- ) Exit function if TOS is a non-zero flag" :doc

: within ( xlu-f ) &over dip <= &>= dip and ;
" ( xlu-f ) Is (x) within lower (l) and upper (u) bounds?" :doc

( Data Structures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
: variable:  ( n"-  ) create , ;
" ( n``- ) Create a new variable with an initial value " :doc

: variable   (  "-  ) 0 variable: ;
" ( ``- ) Create a new variable with an initial value of 0" :doc

: constant   ( n"-  ) create @last !d->xt ;
" ( n``- ) Create a numeric constant" :doc

: string:    ( $"-  ) keepString constant ;
" ( $``- ) Create a string constant" :doc

: allot      (  n-  ) dup 0 < [ +heap ] [ [ 0 , ] times ] if ;
" ( n- ) Allocate space in the heap" :doc

{{
  : list     (  n-a ) here swap allot ;
  : element  (  a-a ) create dup @last !d->xt 1+ ;
---reveal---
  : elements ( n"-  ) dup list swap &element times drop ;
  " ( n``- ) Create a series of variables" :doc
}}

( Numbers and Math ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
: decimal ( - ) 10 !base ;
" ( - ) Switch **base** to 10" :doc

: hex     ( - ) 16 !base ;
" ( - ) Switch **base** to 16" :doc

: octal   ( - )  8 !base ;
" ( - ) Switch **base** to  8" :doc

: binary  ( - )  2 !base ;
" ( - ) Switch **base** to  2" :doc

( Output ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
{{
  create buf   32 allot
  2 elements digits pos
  : split    (   n-... )
    repeat @base /mod swap numbers + @ swap digits ++ 0; again ;
  : build    ( ...-    )
    buf @pos [ @pos swap !+ ] ifTrue
    @digits [ !+ ] times 0 swap ! ;
  : negate?  (   n-n   ) dup 0 >= if; negate 45 !pos ;
---reveal---
  : toString (   n-$   ) 0 [ !pos ] [ !digits ] bi negate? split build buf ;
  " ( n-$ ) Convert a number into a string" :doc
}}

: clear (  - ) -1 putc ;
" ( - ) Clear the display" :doc

: space (  - ) 32 putc ;
" ( - ) Display a space character (ASCII 32)" :doc

: putn  ( n- ) toString puts ;
" ( n- ) Display a number" :doc

( Parsing prefixes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
: .parse  (  a- ) do ;
" ( a- ) Class for parsing prefixes" :doc

: parsing (   - ) &.parse reclass ;
" ( - ) Set most recent function to **.parse** class" :doc

{{
  : number ( a- ) base [ do toNumber .data ] preserve ;
---reveal---
  : __$   ( $-n ) &hex     number ; parsing
  " ( $-n ) Prefix; treat number as hexadecimal (base" :doc

  : __#   ( $-n ) &decimal number ; parsing
  " ( $-n ) Prefix; treat number as decimal (base 10)" :doc

  : __%   ( $-n ) &binary  number ; parsing
  " ( $-n ) Prefix; treat number as binary (base 2)" :doc

  : __'   ( $-n ) @ .data         ; parsing
  " ( $-n ) Return character following '" :doc
}}


( Chained Vocabularies ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
create dicts 64 allot
" ( -a ) Array; used by chained vocabularies and search order code" :doc

{{
  2 elements active prior
  create "|" 124 ,  0 ,
  create "%%" 37 , 37 , 0 ,
  : seal   (  - ) last [ @ 0; @active over @ == ] until 0 swap ! ;
  : revert (  - ) @prior 0; !last 0 !prior ;
  : safety (  - ) "%%" header immediate &revert @last !d->xt ;
---reveal---
  : %%     (  - ) revert ;
  " ( - ) Close a vocabulary. Use with caution" :doc

  : <%>    ( a- ) @last !prior !last ;
  " ( a- ) Open a vocabulary. Use with caution" :doc

  : .chain ( a- ) @dicts &drop &<%> if ;
  " ( a- ) Class for vocabularies" :doc

  : chain: ( "- ) create 0 , &.chain reclass @last !active safety ;
  " ( ``- ) Create a new vocabulary" :doc

  : ;chain (  - ) seal @last @active [ !last ] [ !d->xt ] bi ;
  " ( - ) End a vocabulary" :doc

  : :with  ( a- ) 0; @dicts 1+ dicts + ! dicts ++ ;
  " ( a- ) Add a vocabulary to the search order (by pointer)" :doc

  : with   ( "- ) ' :with ;
  " ( ``- ) Add a vocabulary to the search order (parses for name)" :doc

  : without ( - ) @dicts 0; 1- !dicts ;
  " ( - ) Remove a vocabulary from the search order " :doc

  : global  ( - ) 0 !dicts ;
  " ( - ) Remove all vocabularies from the search order, leaving just the global dictionary " :doc

  : findInChain ( $a-df ) :with find without ;
  " ( $a-df ) Open a chain (using **:with**) and search for a name. Closes the chain when done." :doc

  : with|  ( "- )
    global
    repeat
      32 accept tib "|" compare if;
      tib find [ @d->xt :with ] &drop if
    again ;
  " ( ``- ) Open a series of vocabularies, ending when ``  is encountered" :doc
}}

: rename: ( a"- )
  create dup xt->d swap :hide
  [ @d->xt @last !d->xt ] [ @d->class @last !d->class ] bi ;
" ( a``- ) Rename a function" :doc

( Extend 'find' and 'xt->d' to search chains before global ~~~~~~~~~~~~~~~~~~ )
{{
  5 elements flag dt name safety xt
  : search  (  -   ) @dicts repeat 0; dup dicts + <%> @xt do 1- again ;
  : (chains ( $-   ) !name 0 [ !dt ] [ !flag ] bi @last !safety ;
  : back)   (   -  ) @safety !last ;
  : seek    ( na-n ) @name default: find [ !dt flag on drop 1 ] &drop if ;
  : lookup  ( $-af )
    &seek !xt (chains search back)
    @flag [ @dt @flag ] [ @name default: find ] if ;
  &lookup is find

  : seek    (   -  )
    @name default: xt->d ?dup [ !dt flag on drop 1 ] ifTrue ;
  : lookup  (  a-d )
    &seek !xt (chains search back)
    @flag [ @dt ] [ @name default: xt->d ] if ;
  &lookup is xt->d
}}

( Extend Prefix Handler ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
{{
  4 elements xt class name flag
  create ___ 95 , 95 , 95 , 0 ,

  ( Split Token into Prefix and Name ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
  : action   (  -   ) @xt @class withClass ;
  : (split   (  -a  ) @+ ___ tuck 1+ 1+ ! swap !name ;
  : prefix)  ( $-f  )
    find [ [ @d->class !class ] [ @d->xt !xt ] bi -1 ] [ 0 ] if ;

  ( Prefix Handling ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
  : handle   (  -   )
    @class &.parse ==
    [ flag off @name action ]
    [ @name find [ @d->xt action flag off ] &drop if ]
    if ;

  ( Main Wrapper ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
  : try      (  -   )
    flag on tib (split prefix) &handle &drop if @flag ;
  &try is <notFound>
}}

( Core Strings ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
{{
  : buffers  ( -a )
    @memory        STRING-LENGTH   -  ( tib     )
                   STRING-LENGTH   -  ( scratch )
    STRING-BUFFERS STRING-LENGTH * -  ( buffers ) ;
  variable next
---reveal---
  : tempString ( $-$ )
    withLength 1+
    @next STRING-BUFFERS == [ 0 !next ] ifTrue
    @next STRING-LENGTH * buffers + [ swap copy ] sip
    next ++ ;
  " ( a-a ) Move a string to a temporary buffer" :doc
}}

hide "   ( next we define __" and can use proper strings )

{{
  variable end
  : pad  ( -a )
    @memory        STRING-LENGTH   -  ( tib     )
                   STRING-LENGTH   -  ( scratch ) ;
  : keep    (  -  ) @compiler &keepString &tempString if .data ;
  : >pad    ( $-$ ) pad over getLength 1+ copy pad keep ;
  : chop    ( $-$ ) end -- 0 @end ! ;
  : >$      ( n-  ) dup 8 == [ chop drop ] [ @end !+ !end ] if ;
  : end?    ( $-$ ) @end @1- '" == [ chop >pad -1 ] [ 0 ] if ;
  : noEat   ( q-  ) eatLeading? off do eatLeading? on ;
  : withPad ( q-  ) 32 pad 1- ! &pad &tib :is noEat &tib :devector ;
  : get     (  -c ) getc dup putc ;
---reveal---
  : __"  ( "-a )
    dup withLength + !end
    end? [ 32 >$ [ end? [ 0 ] [ get >$ -1 ] if ] while ] ifFalse ; parsing
  "( ``-$ ) Prefix; parse and return a string" :doc

  : "    ( "-$ ) [ '" accept pad 1- keep ] withPad ; immediate
  "( ``-$ ) Parse and return a string" :doc
}}

( Formatted String Display ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
-1 variable: formatted
"( -a ) Variable; toggles whether **puts** uses escape sequences or not" :doc

{{
  : withBase ( n$q-$ ) &swap dip base &do preserve ;
  : char ( $-$ )
    @+ [ 'n == ] [ cr      ] whend
       [ '' == ] [ '" putc ] whend
       [ '[ == ] [ 27 putc putc ] when
    putc ;
  : obj  ( $-$ )
    @+ [ 'd == ] [ [ decimal putn ] withBase ] whend
       [ 'o == ] [ [ octal   putn ] withBase ] whend
       [ 'x == ] [ [ hex     putn ] withBase ] whend
       [ 'c == ] [ swap putc                 ] whend
       [ 's == ] [ formatted off &puts dip formatted on ] whend
       putc ;
  : complex ( $-n )
    repeat
      @+ 0;
      dup '\ == [ drop char 0 ] ifTrue
      dup '% == [ drop obj  0 ] ifTrue
      putc
    again ;
  : simple ( $- ) [ @ putc ] 2 ( STRING ) each@ ;
  [ update off @formatted [ complex drop ] &simple if update on redraw ] is <puts>
}}

( Debugging ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
: depth   (    -n ) -5 5 out wait 5 in ;
"( -n ) Return number of items on stack" :doc

: reset   ( ...-  ) depth repeat 0; 1- nip again ;
"( ...- ) Remove all items from stack" :doc

{{
  : (.s)  0; 1- swap push (.s) pop dup putn space ;
---reveal---
  : .s    depth [ "\n<%d> " puts ] sip (.s) ;
  "( - ) Display all items on stack" :doc
}}

{{
  : list    ( a-  ) [ d->name puts space ] 3 ( ^types'LIST ) each@ ;
  : others  (  -  ) @dicts repeat 0; cr dup dicts + list 1- again ;
---reveal---
  : words   (  -  ) cr formatted dup [ off others cr last list ] preserve ;
  "( - ) List all names in dictionary" :doc
}}


( Keymap ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )

{{
  : dictionary.find/xt ( string:name - xt )  find [ @d->xt ] [ drop #0 ] if ;

  : prefix?
    dup "keymap:PREFIX" dictionary.find/xt @ == ;

  : seekHandler
    dup "keymap:TABLE"  dictionary.find/xt + @ ;

  [ prefix? [ drop getc:unfiltered seekHandler dup 0 <> [ nip dip cr ] [ 2drop ] if 0 ] ifTrue ] is keymap:handler
}}

( Misc. Words ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
: save     (  -  ) 1 4 out wait ;
"( - ) Save the image" :doc

: bye      (  -  ) cr -9 5 out wait ;
"( - ) Exit Retro" :doc

: getToken ( "-$ ) 32 accept tib tempString ;
"( ``-$ ) Read a string, stopping at first whitespace" :doc

: getNumber ( "-n )  getToken toNumber ;
"( ``-n ) Read a number from the input stream" :doc

: :include ( $-  ) 2 4 out wait ;
"( $- ) Include a file" :doc

: include  ( "-  ) getToken :include ;
"( ``- ) Same as **:include**, but parse for file name" :doc

: time     (  -n ) -8 5 out wait 5 in ;
"( -n ) Return the current unix time" :doc

: delay    ( n-  ) time + [ dup time > ] while drop ;
"( n- ) Delay for (approximately) n seconds" :doc

: getEnv   ( a$- ) -10 5 out wait ;
"( a$- ) Get a copy of environment variable $ in buffer" :doc

: later    (  -  ) 2pop swap 2push ;
"( - ) Defer execution of caller until a later time" :doc

{{
  : xt,   ( - ) 1 , @last @d->xt , ;
---reveal---
  : yield ( - ) 1 , here 5 + , xt, ` :is 9 , xt,  ` :devector ; compile-only
  "( - ) Return from a function, with execution resuming from point after **yield** when the  function is next called" :doc
}}

: doc{     ( "-  ) repeat getToken "}doc" compare if; again ;
"( ``- ) Parse tokens up to *}doc* and ignore.\n\nThis is intended as a means of embedding docs into libraries." :doc

: variables|  ( "- )
  repeat getToken "|" compare if; tib header 0 , again ;
"( ``- ) Create a series of variables" :doc

( Internal Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
global
chain: internals'
  &quote  create quote  @last !d->xt &.word reclass
  "( -a ) Helper function for quotations" :doc

  &string create string @last !d->xt &.word reclass
  "( -a ) Helper function for strings" :doc
;chain
"( - ) vocabulary containing functions used internally by Retro" :doc

hide string
hide quote

( Generic Buffer ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
global
chain: buffer'
{{
  variables| buffer ptr |
  : terminate (  -  ) 0 @ptr ! ;
---reveal---
  : start     (  -a ) @buffer  ;
  "( -a ) Get starting address of buffer" :doc

  : end       (  -a ) @ptr     ;
  "( -a ) Address at end of buffer" :doc

  : add       ( c-  ) end ! ptr ++ terminate ;
  "( c- ) Add value to end of buffer" :doc

  : get       (  -c ) ptr -- end @ terminate ;
  "( -c ) Read and remove value from buffer" :doc

  : empty     (  -  ) start !ptr   terminate ;
  "( - ) Remove everything from the buffer" :doc

  : size      (  -n ) end start -   ;
  "( -n ) Number of values in buffer" :doc

  : set       ( a-  ) !buffer empty ;
  "( a- ) Set buffer to memory address and empty it" :doc
}}
;chain
"( - ) vocabulary for dealing with LIFO buffers" :doc

( Text Strings ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
with buffer'
chain: strings'
{{
  variables| len needle haystack flag right left src |
  : buffer  ( -a )
    @memory        STRING-LENGTH   -  ( tib     )
                   STRING-LENGTH   -  ( scratch ) ;
  : trim   ( $-$ )
    dup withLength + 1- dup @ 32 == [ 0 swap ! dup 1- -- trim ] &drop if ;
  : place  ( $$n- ) [ copy 0 ] sip here + ! ;
  : prep   (  $$- ) swap !haystack [ getLength !len ] [ !needle ] bi 0 !flag ;
  : move   (    - ) @haystack here @len place haystack ++ ;
  : cmp    (    - )
    @flag 0 != if; @needle here compare [ @haystack 1- !flag ] ifTrue ;
---reveal---
  : search   ( $$-f )
    flag off prep @haystack getLength [ move cmp ] times @flag ;
  "( $$-f ) Search for a string (2) within a string (1); return string starting with substring" :doc

  : findChar ( $c-a )
    !needle
    repeat @+
      dup 0   == [ 2drop 0 0 ] [ -1 ] if 0; drop
      @needle == [ 1-      0 ] [ -1 ] if 0; drop
    again ;
  "( $c-a ) Search for a character within a string; return string starting at the character" :doc

  : chop      ( $-$ ) tempString withLength over + 1- 0 swap ! ;
  "( $-$ ) Return a new string, with the last byte removed" :doc

  : getSubset ( $nn-$ )
    buffer 0 STRING-LENGTH fill
    !right !left !src
    @src @left + @right buffer swap copy buffer tempString ;
  "( $nn-$ ) Return a subset of ($) starting at (n1) with length of (n2)" :doc

  : trimLeft  ( $-$ ) [ @+ [ 32 == ] [ 0 != ] bi and ] while 1- ;
  "( $-$ ) Trim whitespace from left side of string" :doc

  : trimRight ( $-$ )
    buffer [ 0 STRING-LENGTH fill ] [ over getLength copy ] [ trim ] tri tempString ;
  "( $-$ ) Trim whitespace from right side of string" :doc

  : prepend ( $$-$ )
    buffer 0 STRING-LENGTH fill
    withLength buffer swap &copy sip
    &withLength dip buffer + swap copy buffer tempString ;
  "( $$-$ ) Append first string to second" :doc

  : append ( $$-$ ) swap prepend ;
  "( $$-$ ) Append second string to first" :doc

  : appendChar ( $c-$ ) swap tempString [ withLength + !+ 0 swap ! ] sip ;
  "( $c-$ ) Append character to a string" :doc

  : toLower  ( $-$ )
    tempString [ [ dup @ dup 'A 'Z within [ 32 + ] ifTrue swap ! ] 2 each@ ] sip ;
  "( $-$ ) Convert a string to all upper case" :doc

  : toUpper  ( $-$ )
    tempString [ [ dup @ dup 'a 'z within [ 32 - ] ifTrue swap ! ] 2 each@ ] sip ;
  "( $-$ ) Convert a string to all upper case" :doc
}}
  : reverse ( $-$ )
    dup tempString set
    &getLength [ withLength + 1- ] bi swap
    [ dup @ add 1- ] times drop
    start tempString ;
  "( $-$ ) Reverse the characters in a string; returns a new string" :doc

  : split ( $n-$$ )
    2over 0 swap getSubset &+ dip ;
  "( $n-$$ ) Split a string into two parts" :doc

  : splitAtChar ( $c-$$ )
    2over over swap findChar over - 1+ 0 swap getSubset [ findChar 1+ ] dip ;
  "( $c-$$ ) Search for a character and return two strings (up to and including (c), and after ($2))" :doc

  : splitAtChar: ( $"-$$ )
    @getToken .data ` splitAtChar ; immediate
  "( $``-$$ ) Parse for a character and call **splitAtChar**" :doc
;chain
without
"( - ) vocabulary with functions for dealing with strings" :doc

( Access Words Within Chains Directly ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
with strings'
: __^  ( "- )
  splitAtChar: ' find
  [ @d->xt findInChain [ [ @d->xt ] [ @d->class ] bi withClass ] &drop if ]
  &drop if ; parsing
"( ``- ) Allow direct access to functions in a chain" :doc

: :needs  ( $- )
  dup find nip
  &drop [ "library/" prepend chop ".rx" append :include ] if ;
"( $- ) Load a vocabulary from the library if not already loaded" :doc

: needs  ( "- )
  getToken :needs ;
"( ``- ) Load a vocabulary from the *library* if it is not already loaded (parsing)" :doc

 without

( types' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
chain: types'
  0 constant ARRAY  ( -n )
  "( -n ) Type constant for arrays" :doc

  1 constant BUFFER ( -n )
  "( -n ) Type constant for buffers" :doc

  2 constant STRING ( -n )
  "( -n ) Type constant for strings" :doc

  3 constant LIST   ( -n )
  "( -n ) Type constant for linked lists" :doc
;chain
"( - ) vocabulary with constants for data types. Used with **each@**" :doc

: describe
  d' 0; cr
  dup d->class @ xt->d dup [ d->name ] [ drop "unknown" ] if "class: %s\n" puts
      d->doc @ dup [ ] [ drop "no documentation provided" ] if puts cr ;
"( ``- ) provide information about a function" :doc

( cleanup and save ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
global .s save bye
